else{
return(FALSE)
}
}
# scales a vector to sum to 1
sum.to.1 <- function(x){
x / sum(x)
}
# a function for generating "expressions" in the form of lists:
# first element is the index of a function in the library
# subsequent elements are the arguments to that function, which can
# be expressions themselves, or the indices of constants in the library
make.expr <- function(n.layer){
# choose a function
bin <- sample(length(fun.bins),
size = 1,
prob = fun.bin.mass)
fun.index <- sample(fun.bins[[bin]], size = 1)
fun.arg.ct.0 <- fun.arg.ct[fun.index]
# initialize the expression
expr <- vector("list", length = 1 + fun.arg.ct.0)
expr[[1]] <- fun.index
if(n.layer == 1){
# all arguments are constants
for(i in 1 + 1:fun.arg.ct.0){
# choose a constant
bin <- sample(length(con.bins),
size = 1,
prob = con.bin.mass)
con.index <- sample(con.bins[[bin]], size = 1)
expr[[i]] <- con.index
}
return(expr)
}
else{
# number of arguments to this function which will be expressions ("sub-expressions")
n.sub.expr <- sample(fun.arg.ct.0,size = 1)
# which arguments to this function will be expressions
which.sub.expr <- sample(fun.arg.ct.0, size = n.sub.expr)
# populate the arguments to this function with expressions or constants
for(i in 1 + 1:fun.arg.ct.0){
if((i - 1) %in% which.sub.expr){
expr[[i]] <- make.expr(n.layer - 1)
}
else{
# choose a constant
bin <- sample(length(con.bins),
size = 1,
prob = con.bin.mass)
con.index <- sample(con.bins[[bin]], size = 1)
expr[[i]] <- con.index
}
}
return(expr)
}
}
# sort the arguments of the + and * functions within an expression into
# a standard order
std.expr <- function(expr){
f <- expr[[1]]
a <- expr[[2]]
if(is.list(a)){
a <- std.expr(a)
}
if(fun.arg.ct[f] == 2){
b <- expr[[3]]
if(is.list(b)){
b <- std.expr(b)
}
}
if(f == 17 || f == 19){ # + || *
if(is.list(a) & is.numeric(b)){
x <- b
b <- a
a <- x
}
else if (is.numeric(a) && is.numeric(b)) {
x <- c(a,b)[order(con.order[c(a,b)])]
a <- x[1]
b <- x[2]
}
expr[[2]] <- a
expr[[3]] <- b
}
return(expr)
}
# evaluate an expression as generated by make.expr
eval.expr <- function(expr){
if(is.list(expr)){
f <- fun.lib[[expr[[1]]]]
a <- eval.expr(expr[[2]])
if(is.na(a)){
return(NA)
}
l <- length(expr)
if(l == 2){
result <- f(a)
}
else if(l == 3){
b <- eval.expr(expr[[3]])
if(is.na(b)){
return(NA)
}
result <- f(a,b)
}
if(is.na(result) | is.nan(result) | is.infinite(result)){
return(NA)
}
else{
return(result)
}
}
else{
if(is.na(expr)){
return(NA)
}
else{
result <- con.lib[expr]
return(result)
}
}
}
# write an expression's LaTeX representation
to.LaTeX.raw <- function(expr){
f <- expr[[1]]
a <- expr[[2]]
if(is.numeric(a)){
a <- con.TeX[a]
}
else if(is.list(a)){
a <- to.LaTeX.raw(a)
}
if(fun.arg.ct[f] == 2){
b <- expr[[3]]
if(is.numeric(b)){
b <- con.TeX[b]
}
else if(is.list(b)){
b <- to.LaTeX.raw(b)
}
}
if(f == 1){ # cos
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\cos", a)
}
else if(f == 2){ # sin
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\sin", a)
}
else if(f == 3){ # tan
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\tan", a)
}
else if(f == 4){ # cosh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\cosh", a)
}
else if(f == 5){ # sinh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\sinh", a)
}
else if(f == 6){ # tanh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\tanh", a)
}
else if(f == 7){ # acos
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\acos", a)
}
else if(f == 8){ # asin
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\asin", a)
}
else if(f == 9){ # atan
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\atan", a)
}
else if(f == 10){ # acosh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\acosh", a)
}
else if(f == 11){ # asinh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\asinh", a)
}
else if(f == 12){ # atanh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\atanh", a)
}
else if(f == 13){ # ln
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\ln", a)
}
else if(f == 14){ # log_b
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\log_{", b, "}", a)
}
else if(f == 15){ # sqrt
TeX <- paste0("\\sqrt{", a, "}")
}
else if(f == 16){ # sqrt_b
TeX <- paste0("\\sqrt[", b, "]{", a, "}")
}
else if(f == 17){ # +
TeX <- paste0(a, "+", b)
}
else if(f == 18){ # -
if(free.operators(x = b, operators = c("+", "-"))){
b <- enclose(b)
}
TeX <- paste0(a, "-", b)
}
else if(f == 19){ # *
if(free.operators(x = a, operators = c("+", "-"))){
a <- enclose(a)
}
if(free.operators(x = b, operators = c("+", "-"))){
b <- enclose(b)
}
# use gsub to remove *s later, but they're needed to check
# whether a should be enclosed in a^b
TeX <- paste0(a, "*", b)
}
else if(f == 20){ # /
# use / as a single-character representation of frac
# use gsub to switch it for the real thing later
TeX <- paste0("\\/{", a, "}{", b, "}")
}
else if(f == 21){ # 1/a
TeX <- paste0("\\/{1}{", a, "}")
}
else if(f == 22){ # ^
if(free.operators(x = a, operators = c("+", "-", "*", "/", "^"))){
a <- enclose(a)
}
TeX <- paste0(a, "^{", b, "}")
}
return(TeX)
}
# convert expression to standard order, then to LaTeX, then switch
# out intermediate characters
to.LaTeX <- function(expr){
expr <- std.expr(expr)
TeX <- to.LaTeX.raw(expr)
TeX <- gsub(pattern = "/", replacement = "frac", x = TeX)
TeX <- gsub(pattern = "[*]", replacement = " ", x = TeX)
return(TeX)
}
# constant library
con.lib <- c("pi" = pi,
"baseNatLog" = exp(1),
"goldenRatio" = (1 + sqrt(5))/2,
"EulerMascheroni" = 0.5772156649,
"one" = 1,
"sqrt2" = sqrt(2),
"ln2" = log(2),
"Catalan" = 0.915965594177,
"FeigenbaumDelta" = 4.6692016091,
"FeigenbaumAlpha" = 2.502907875096,
"FransenRobinson" = 2.8077702420285,
"KeplerBouwkamp" = 0.11494204485,
"KomornikLoreti" = 1.78723165018,
"univParabolic" = 2.29558714939,
"Niven" = 1.7052111401,
"MeisselMertens" = 0.2614972128476,
"Backhouse" = 1.45607494858,
"Gauss" = 0.834626841674,
"Soldner" = 1.45136923488,
"SomosQuadRec" = 1.66168794963,
"omega" = 0.5671432904,
"RecipFibonacci" = 3.35988566624,
"Khinchin" = 2.685452001065,
"GlaisherKinkelin" = 1.2824271291006,
"Apery" = 1.20205690315959,
"Madelung3" = -1.74756459463318,
"twinPrimes" = 0.660161815846869,
"lemniscate" = 2.622057554292,
"LandauRamanujan" = 0.764223653589,
"Grossman" = 0.73733830336929,
"Foias" = 1.187452351126501,
"paperFolding" = 0.850736188201867
)
# constant LaTeX representations
# make sure this is in the same order as con.lib
con.TeX <- c("pi" = "\\pi",
"baseNatLog" = "e",
"goldenRatio" = "\\phi",
"EulerMascheroni" = "\\gamma",
"one" = "1",
"sqrt2" = "\\sqrt{2}",
"ln2" = "\\ln(2)",
"Catalan" = "K",
"FeigenbaumDelta" = "\\delta",
"FeigenbaumAlpha" = "\\alpha",
"FransenRobinson" = "F",
"KeplerBouwkamp" = "\\rho",
"KomornikLoreti" = "q",
"univParabolic" = "P",
"Niven" = "C",
"MeisselMertens" = "M",
"Backhouse" = "B",
"Gauss" = "G",
"Soldner" = "\\mu",
"SomosQuadRec" = "\\sigma",
"omega" = "\\Omega",
"RecipFibonacci" = "\\psi",
"Khinchin" = "K_{0}",
"GlaisherKinkelin" = "A",
"Apery" = "\\zeta(3)",
"Madelung3" = "M_{3}",
"twinPrimes" = "\\Pi_{2}",
"lemniscate" = "L",
"LandauRamanujan" = "K_{LR}",
"Grossman" = "\\eta",
"Foias" = "\\xi",
"paperFolding" = "\\sigma_{p}"
)
# 1 = always first
# lower Greek = 0
# upper Greek = 1
# lower Latin = 2
# upper Latin = 3
# Apery = 98
# ln(2) = 99
# sqrt(2) = always last
con.order <- c("pi" = 0.16,
"baseNatLog" = 2.05,
"goldenRatio" = 0.21,
"EulerMascheroni" = 0.03,
"one" = -Inf,
"sqrt2" = Inf,
"ln2" = 99,
"Catalan" = 3.11,
"FeigenbaumDelta" = 0.04,
"FeigenbaumAlpha" = 0.01,
"FransenRobinson" = 3.06,
"KeplerBouwkamp" = 0.17,
"KomornikLoreti" = 2.17,
"univParabolic" = 3.16,
"Niven" = 3.03,
"MeisselMertens" = 3.13,
"Backhouse" = 3.02,
"Gauss" = 3.07,
"Soldner" = 0.12,
"SomosQuadRec" = 0.18,
"omega" = 1.24,
"RecipFibonacci" = 0.23,
"Khinchin" = 3.1101,
"GlaisherKinkelin" = 3.01,
"Apery" = 98,
"Madelung3" = 3.1303,
"twinPrimes" = 1.1602,
"lemniscate" = 3.12,
"LandauRamanujan" = 3.11001218,
"Grossman" = 0.07,
"Foias" = 0.14,
"paperFolding" = 0.1816
)
# define the functions that will go into the function library
f01 <- function(a){cos(a)}
f02 <- function(a){sin(a)}
f03 <- function(a){tan(a)}
f04 <- function(a){cosh(a)}
f05 <- function(a){sinh(a)}
f06 <- function(a){tanh(a)}
f07 <- function(a){acos(a)}
f08 <- function(a){asin(a)}
f09 <- function(a){atan(a)}
f10 <- function(a){acosh(a)}
f11 <- function(a){asinh(a)}
f12 <- function(a){atanh(a)}
f13 <- function(a){log(a)}
f14 <- function(a, b){log(a, base = b)}
f15 <- function(a){sqrt(a)}
f16 <- function(a, b){a^(1/b)}
f17 <- function(a, b){a + b}
f18 <- function(a, b){a - b}
f19 <- function(a, b){a * b}
f20 <- function(a, b){a / b}
f21 <- function(a){1/a}
f22 <- function(a, b){a^b}
# the function library, for accessing functions by index
fun.lib <- c(f01, f02, f03, f04, f05,
f06, f07, f08, f09, f10,
f11, f12, f13, f14, f15,
f16, f17, f18, f19, f20,
f21, f22)
# the number of arguments taken by each function
fun.arg.ct <- sapply(X = fun.lib,
FUN = function(x){
length(formals(x))
})
# constant bins: want to somewhat overrepresent the more
# common/popular/well-known constants
con.bins <- list("common" = 1:7,
"uncommon" = 8:32)
# define the distribution from which to draw the constant bins
con.bin.mass <- sum.to.1(c("common" = 1,
"uncommon" = 1))
# function bins: because ~half the functions are trig, but we don't
# want our random sample of functions to tend to be half trig
fun.bins <- list("trig" = 1:12,
"log" = 13:14,
"rad" = 15:16,
"arith" = 17:21,
"pow" = 22)
# define the distribution from which to draw the function bins
fun.bin.mass <- sum.to.1(c("trig" = 8,
"log" = 3,
"rad" = 4,
"arith" = 10,
"pow" = 2))
# define the distribution from which to draw the
# number of layers of the expressions
layer.mass <- sum.to.1(c("1" = 2,
"2" = 5,
"3" = 2,
"4" = 1))
# keep going until we generate this many valid calendar dates
n.days <- 10000
# limit the number of times a single date can be generated
# before we start throwing it out in favor of other, less
# represented dates
tol <- 0.15
max.day.count <- ceiling(n.days / 365.25 * (1 + tol))
# invalid calendar dates
non.days <- c(230, 231, 431, 631, 931, 1131)
# our output calendar
calendar <- as.data.frame(matrix(ncol = 4, nrow = n.days))
colnames(calendar) <- c("MO", "DY", "VAL", "LATEX")
# count the number of times each date is generated
day.counter <- matrix(0, nrow = 12, ncol = 31)
for(day in 1:n.days){
# initialize to nonsense
expr.value <- NA
expr.int <- 230
MO <- 2
DY <- 30
day.count <- 0
# make random expressions until one is a valid date
while(is.na(expr.value) |
expr.int %in% non.days |
expr.value < 1 |
MO < 1 |
MO > 12 |
DY < 1 |
DY > 31 |
day.count >= max.day.count){
n.layer <- sample(x = length(layer.mass),
size = 1,
prob = layer.mass)
expr <- make.expr(n.layer)
expr.value <- eval.expr(expr)
if(!is.na(expr.value)){
expr.int <- floor(expr.value * 100)
if(is.infinite(expr.int)){
DY <- 69
MO <- 420
} else {
DY <- expr.int %% 100
MO <- (expr.int - DY) / 100
}
if(MO >= 1 & MO <= 12 & DY >= 1 & DY <= 31){
day.count <- day.counter[MO, DY]
}
}
}
# fill in this row of the calendar
calendar$MO[day] <- MO
calendar$DY[day] <- DY
calendar$VAL[day] <- expr.value
calendar$LATEX[day] <- to.LaTeX(expr)
# tally the date
day.counter[MO, DY] <- day.count + 1
cat("\r              \r",
day, "/", n.days, sep = "")
}
# clean up before output
calendar <- calendar[!duplicated(calendar$LATEX),]
calendar <- calendar[order(calendar$VAL),]
write.table(x = calendar,
file = "./calendar/days_latex_V5.csv",
sep = ",",
row.names = F)
