return(TRUE)
}
else{
return(FALSE)
}
}
# scales a vector to sum to 1
sum.to.1 <- function(x){
x / sum(x)
}
# a function for generating "expressions" in the form of lists:
# first element is the index of a function in the library
# subsequent elements are the arguments to that function, which can
# be expressions themselves, or the indices of constants in the library
make.expr <- function(n.layer){
# choose a function
bin <- sample(length(fun.bins),
size = 1,
prob = fun.bin.mass)
fun.index <- sample(fun.bins[[bin]], size = 1)
fun.arg.ct.0 <- fun.arg.ct[fun.index]
# initialize the expression
expr <- vector("list", length = 1 + fun.arg.ct.0)
expr[[1]] <- fun.index
if(n.layer == 1){
# all arguments are constants
for(i in 1 + 1:fun.arg.ct.0){
# choose a constant
bin <- sample(length(con.bins),
size = 1,
prob = con.bin.mass)
con.index <- sample(con.bins[[bin]], size = 1)
expr[[i]] <- con.index
}
return(expr)
}
else{
# number of arguments to this function which will be expressions ("sub-expressions")
n.sub.expr <- sample(fun.arg.ct.0,size = 1)
# which arguments to this function will be expressions
which.sub.expr <- sample(fun.arg.ct.0, size = n.sub.expr)
# populate the arguments to this function with expressions or constants
for(i in 1 + 1:fun.arg.ct.0){
if((i - 1) %in% which.sub.expr){
expr[[i]] <- make.expr(n.layer - 1)
}
else{
# choose a constant
bin <- sample(length(con.bins),
size = 1,
prob = con.bin.mass)
con.index <- sample(con.bins[[bin]], size = 1)
expr[[i]] <- con.index
}
}
return(expr)
}
}
# evaluate an expression as generated by make.expr
eval.expr <- function(expr){
if(is.list(expr)){
f <- fun.lib[[expr[[1]]]]
a <- eval.expr(expr[[2]])
if(is.na(a)){
return(NA)
}
l <- length(expr)
if(l == 2){
result <- f(a)
}
else if(l == 3){
b <- eval.expr(expr[[3]])
if(is.na(b)){
return(NA)
}
result <- f(a,b)
}
if(is.na(result) | is.nan(result) | is.infinite(result)){
return(NA)
}
else{
return(result)
}
}
else{
if(is.na(expr)){
return(NA)
}
else{
result <- con.lib[expr]
return(result)
}
}
}
# write the precursor to an expression's LaTeX representation
to.LaTeX.raw <- function(expr){
f <- expr[[1]]
a <- expr[[2]]
if(is.numeric(a)){
a <- con.TeX[a]
}
else if(is.list(a)){
a <- to.LaTeX.raw(a)
}
if(fun.arg.ct[f] == 2){
b <- expr[[3]]
if(is.numeric(b)){
b <- con.TeX[b]
}
else if(is.list(b)){
b <- to.LaTeX.raw(b)
}
}
if(f == 1){ # cos
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\cos", a)
}
else if(f == 2){ # sin
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\sin", a)
}
else if(f == 3){ # tan
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\tan", a)
}
else if(f == 4){ # cosh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\cosh", a)
}
else if(f == 5){ # sinh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\sinh", a)
}
else if(f == 6){ # tanh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\tanh", a)
}
else if(f == 7){ # acos
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\acos", a)
}
else if(f == 8){ # asin
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\asin", a)
}
else if(f == 9){ # atan
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\atan", a)
}
else if(f == 10){ # acosh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\acosh", a)
}
else if(f == 11){ # asinh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\asinh", a)
}
else if(f == 12){ # atanh
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\atanh", a)
}
else if(f == 13){ # ln
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\ln", a)
}
else if(f == 14){ # log_b
if(!is.enclosed(a)){
a <- enclose(a)
}
TeX <- paste0("\\log_{", b, "}", a)
}
else if(f == 15){ # sqrt
TeX <- paste0("\\sqrt{", a, "}")
}
else if(f == 16){ # sqrt_b
TeX <- paste0("\\sqrt[", b, "]{", a, "}")
}
else if(f == 17){ # +
TeX <- paste0(a, "+", b)
}
else if(f == 18){ # -
if(free.operators(x = b, operators = c("+", "-"))){
b <- enclose(b)
}
TeX <- paste0(a, "-", b)
}
else if(f == 19){ # *
if(free.operators(x = a, operators = c("+", "-"))){
a <- enclose(a)
}
if(free.operators(x = b, operators = c("+", "-"))){
b <- enclose(b)
}
# use gsub to remove *s later, but they're needed to check
# whether a should be enclosed in a^b
TeX <- paste0(a, "*", b)
}
else if(f == 20){ # /
# use / as a single-character representation of frac
# use gsub to switch it for the real thing later
TeX <- paste0("\\/{", a, "}{", b, "}")
}
else if(f == 21){ # 1/a
TeX <- paste0("\\/{1}{", a, "}")
}
else if(f == 22){ # ^
if(free.operators(x = a, operators = c("+", "-", "*", "/", "^"))){
a <- enclose(a)
}
TeX <- paste0(a, "^{", b, "}")
}
return(TeX)
}
# for converting between "asin" and "sin^-1" representations
# of inverse trig functions
trig <- c("cos", "sin", "tan", "cosh", "sinh", "tanh")
# add ( at end because asin matches both asin and asinh,
# but asin( matches asin( and not asinh(
atrig <- paste0("a", trig, "(")
trig.inv <- paste0(trig, "^{-1}")
# wrapper for to.LaTeX raw that switches out intermediate
# characters for their final forms/removes them
to.LaTeX <- function(expr, use.atrig = TRUE){
TeX <- to.LaTeX.raw(expr)
TeX <- gsub(pattern = "/", replacement = "frac", x = TeX)
TeX <- gsub(pattern = "[*]", replacement = " ", x = TeX)
if(!use.atrig){
for(i in 1:6){
TeX <- gsub(pattern = atrig[i],
replacement = trig.inv[i],
x = TeX,
fixed = T)
}
}
# left parentheses are important for matching trig strings,
# so don't switch them out until after switching trig
TeX <- gsub(pattern = "(", replacement = "\\left(", x = TeX, fixed = T)
TeX <- gsub(pattern = ")", replacement = "\\right)", x = TeX, fixed = T)
return(TeX)
}
# constant library
con.lib <- c("pi" = pi,
"baseNatLog" = exp(1),
"goldenRatio" = (1 + sqrt(5))/2,
"EulerMascheroni" = 0.5772156649,
"one" = 1,
"sqrt2" = sqrt(2),
"ln2" = log(2),
"Catalan" = 0.915965594177,
"FeigenbaumDelta" = 4.6692016091,
"FeigenbaumAlpha" = 2.502907875096,
"FransenRobinson" = 2.8077702420285,
"KeplerBouwkamp" = 0.11494204485,
"KomornikLoreti" = 1.78723165018,
"univParabolic" = 2.29558714939,
"Niven" = 1.7052111401,
"MeisselMertens" = 0.2614972128476,
"Backhouse" = 1.45607494858,
"Gauss" = 0.834626841674,
"Soldner" = 1.45136923488,
"SomosQuadRec" = 1.66168794963,
"omega" = 0.5671432904,
"RecipFibonacci" = 3.35988566624,
"Khinchin" = 2.685452001065,
"GlaisherKinkelin" = 1.2824271291006,
"Apery" = 1.20205690315959,
"Madelung3" = -1.74756459463318,
"twinPrimes" = 0.660161815846869,
"lemniscate" = 2.622057554292,
"LandauRamanujan" = 0.764223653589,
"Grossman" = 0.73733830336929,
"Foias" = 1.187452351126501,
"paperFolding" = 0.850736188201867
)
# constant LaTeX representations
# make sure this is in the same order as con.lib
con.TeX <- c("pi" = "\\pi",
"baseNatLog" = "e",
"goldenRatio" = "\\phi",
"EulerMascheroni" = "\\gamma",
"one" = "1",
"sqrt2" = "\\sqrt{2}",
"ln2" = "\\ln(2)",
"Catalan" = "K",
"FeigenbaumDelta" = "\\delta",
"FeigenbaumAlpha" = "\\alpha",
"FransenRobinson" = "F",
"KeplerBouwkamp" = "\\rho",
"KomornikLoreti" = "q",
"univParabolic" = "P",
"Niven" = "C",
"MeisselMertens" = "M",
"Backhouse" = "B",
"Gauss" = "G",
"Soldner" = "\\mu",
"SomosQuadRec" = "\\sigma",
"omega" = "\\Omega",
"RecipFibonacci" = "\\psi",
"Khinchin" = "K_{0}",
"GlaisherKinkelin" = "A",
"Apery" = "\\zeta(3)",
"Madelung3" = "M_{3}",
"twinPrimes" = "\\Pi_{2}",
"lemniscate" = "L",
"LandauRamanujan" = "K_{LR}",
"Grossman" = "\\eta",
"Foias" = "\\xi",
"paperFolding" = "\\sigma_{p}"
)
# define the functions that will go into the function library
f01 <- function(a){cos(a)}
f02 <- function(a){sin(a)}
f03 <- function(a){tan(a)}
f04 <- function(a){cosh(a)}
f05 <- function(a){sinh(a)}
f06 <- function(a){tanh(a)}
f07 <- function(a){acos(a)}
f08 <- function(a){asin(a)}
f09 <- function(a){atan(a)}
f10 <- function(a){acosh(a)}
f11 <- function(a){asinh(a)}
f12 <- function(a){atanh(a)}
f13 <- function(a){log(a)}
f14 <- function(a, b){log(a, base = b)}
f15 <- function(a){sqrt(a)}
f16 <- function(a, b){a^(1/b)}
f17 <- function(a, b){a + b}
f18 <- function(a, b){a - b}
f19 <- function(a, b){a * b}
f20 <- function(a, b){a / b}
f21 <- function(a){1/a}
f22 <- function(a, b){a^b}
# the function library, for accessing functions by index
fun.lib <- c(f01, f02, f03, f04, f05,
f06, f07, f08, f09, f10,
f11, f12, f13, f14, f15,
f16, f17, f18, f19, f20,
f21, f22)
# the number of arguments taken by each function
fun.arg.ct <- sapply(X = fun.lib,
FUN = function(x){
length(formals(x))
})
# constant bins: want to somewhat overrepresent the more
# common/popular/well-known constants
con.bins <- list("common" = 1:7,
"uncommon" = 8:32)
# define the distribution from which to draw the constant bins
con.bin.mass <- sum.to.1(c("common" = 1,
"uncommon" = 1))
# function bins: because ~half the functions are trig, but we don't
# want our random sample of functions to tend to be half trig
fun.bins <- list("trig" = 1:12,
"log" = 13:14,
"rad" = 15:16,
"arith" = 17:21,
"pow" = 22)
# define the distribution from which to draw the function bins
fun.bin.mass <- sum.to.1(c("trig" = 8,
"log" = 3,
"rad" = 4,
"arith" = 10,
"pow" = 2))
# define the distribution from which to draw the
# number of layers of the expressions
layer.mass <- sum.to.1(c("1" = 2,
"2" = 5,
"3" = 2,
"4" = 1))
# keep going until we generate this many valid calendar dates
n.days <- 10000
# limit the number of times a single date can be generated
# before we start throwing it out in favor of other, less
# represented dates
tol <- 0.3
max.day.count <- ceiling(n.days / 365.25 * (1 + tol))
# invalid calendar dates
non.days <- c(230, 231, 431, 631, 931, 1131)
# our output calendar
calendar <- as.data.frame(matrix(ncol = 4, nrow = n.days))
colnames(calendar) <- c("MO", "DY", "VAL", "LATEX")
# count the number of times each date is generated
day.counter <- matrix(0, nrow = 12, ncol = 31)
for(day in 1:n.days){
# initialize to nonsense
expr.value <- NA
expr.int <- 230
MO <- 2
DY <- 30
day.count <- 0
# make random expressions until one is a valid date
while(is.na(expr.value) |
expr.int %in% non.days |
expr.value < 1 |
MO < 1 |
MO > 12 |
DY < 1 |
DY > 31 |
day.count >= max.day.count){
n.layer <- sample(x = length(layer.mass),
size = 1,
prob = layer.mass)
expr <- make.expr(n.layer)
expr.value <- eval.expr(expr)
if(!is.na(expr.value)){
expr.int <- floor(expr.value * 100)
DY <- expr.int %% 100
MO <- (expr.int - DY) / 100
if(MO >= 1 & MO <= 12 & DY >= 1 & DY <= 31){
day.count <- day.counter[MO, DY]
}
}
}
# fill in this row of the calendar
calendar$MO[day] <- MO
calendar$DY[day] <- DY
calendar$VAL[day] <- expr.value
calendar$LATEX[day] <- to.LaTeX(expr)
# tally the date
day.counter[MO, DY] <- day.count + 1
cat("\r              \r",
day, "/", n.days, sep = "")
}
# clean up before output
calendar <- calendar[!duplicated(calendar$LATEX),]
calendar <- calendar[order(calendar$VAL),]
write.table(x = calendar,
file = "./calendar/days_latex_V4.csv",
sep = ",",
row.names = F)
x <- "(\\frac{1}{\\ln(x)})"
gsub(pattern = "(\()[A-z 0-9]{2,}(\))",
replacement = "\\1 \\left( \\2 \\right)",
x = x)
gsub(pattern = "(()[A-z 0-9]{2,}())",
replacement = "\\1 \\left( \\2 \\right)",
x = x)
x <- "(\\frac{1}{\\ln(x)})"
gsub(pattern = "\(([A-z 0-9]{2,})\)",
replacement = "\\left( \\1 \\right)",
x = x)
gsub(pattern = "[(]([A-z 0-9]{2,})[)]",
replacement = "\\left( \\1 \\right)",
x = x)
rm(list = ls())
graphics.off()
##########################
#### Constant Library ####
##########################
e <- exp(1) # e
phi <- (1 + sqrt(5))/2 # golden ratio
gamma <- 0.5772156649 # Euler-Mascheroni
sqrt2 <- sqrt(2)
ln2 <- log(2)
K <- 0.915965594177 # Catalan
delta <- 4.6692016091 # Feigenbaum delta
alpha <- 2.502907875096 # Feigenbaum alpha
F <- 2.8077702420285 # Fransen-Robinson
rho <- 0.11494204485 # polygon inscribing
q <- 1.78723165018 # Komornik-Loreti
P <- 2.29558714939 # universal parabolic
C <- 1.7052111401 # Niven
M <- 0.2614972128476 # Meissel-Mertens
B <- 1.45607494858 # Backhouse
G <- 0.834626841674 # Gauss
mu <- 1.45136923488 # Soldner
sigma <- 1.66168794963 # Somos
OMEGA <- 0.5671432904 # omega
psi <- 3.35988566624 # reciprocal Fibonacci
K0 <- 2.685452001065 # Khinchin's
A <- 1.2824271291006 # Glaisher-Kinkelin
zeta3 <- 1.20205690315959 # Apery's
M3 <- -1.74756459463318 # Madelung for 3D NaCl crystal
Pi2 <- 0.660161815846869 # twin primes
L <- 2.622057554292 # lemniscate
KLR <- 0.764223653589 # Landau-Ramanujan
eta <- 0.73733830336929 # Grossman
xi <- 1.187452351126501 # Foias
sigmap <- 0.850736188201867 # paper folding
F * e + alpha/phi
C * delta + q - gamma
F * e * zeta3
TeX <- "\\zeta\\left(3\\right)"
TeX
gsub(pattern = "\\left(3\\right)", replacement = "(3)", x = TeX, fixed = T)
F * e * zeta3
